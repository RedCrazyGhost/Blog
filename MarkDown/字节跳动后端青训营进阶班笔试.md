# 字节跳动后端青训营进阶班笔试
> 作者 : RedCrazyGhost
> 创建时间 : 2022-04-24
> 修改时间 : 2022-05-04
> 阅读时长 : 13分钟
> 标签 :  <span class="badge bg-primary">Java</span> <span class="badge bg-black">算法</span> 

### Question 1

> 参考 : [LeetCode 695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

```Java
public class Question1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int row=scanner.nextInt();
        int col=scanner.nextInt();
        int[][] arr=new int[row][col];

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                arr[i][j] = scanner.nextInt();
            }
        }

        //BFS（广度优先）
        BFS(arr);
        //DFS（深度优先）
        beforeDFS(arr);
    }

    //BFS 方法实现
    public static void BFS(int[][] arr){
        int row= arr.length;
        int col=arr[0].length;
        boolean[][] isRun=new boolean[row][col];
        Queue<int[]> queue=new ArrayDeque<>();
        int max=0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (arr[i][j]==0&&!isRun[i][j]){
                    queue.add(new int[]{i,j});
                }else{
                    continue;
                }
                int sum=0;
                while(!queue.isEmpty()){
                    int[] arr0=queue.poll();
                    int y=arr0[0];
                    int x=arr0[1];
                    if (y>=0&&y<row&&x>=0&&x<col&&!isRun[y][x]&&arr[y][x]!=1){
                        isRun[y][x]=true;
                        sum+=1;
                        queue.add(new int[]{y,x+1});
                        queue.add(new int[]{y,x-1});
                        queue.add(new int[]{y+1,x});
                        queue.add(new int[]{y-1,x});
                    }
                }
                max=Math.max(max,sum);
            }
        }
        System.out.println(max);
    }

    //DFS 方法实现
    public static void beforeDFS(int[][] arr){
        int max=0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (arr[i][j]==0){
                    max=Math.max(DFS(arr,i,j),max);
                }
            }
        }
        System.out.println(max);
    }
    public static int DFS(int[][] grid, int y, int x) {
        if (grid[y][x] == 1) {
            return 0;
        } else {
            grid[y][x] = 1;
            int num = 1;
            if (y < grid.length - 1) {
                num += DFS(grid, y + 1, x);
            }
            if (x < grid[0].length - 1) {
                num += DFS(grid, y, x + 1);
            }
            if (0 < y) {
                num += DFS(grid, y - 1, x);
            }
            if (0 < x) {
                num += DFS(grid, y, x - 1);
            }
            return num;
        }
    }
}
```

### Question 2

> 参考 : [LeetCode 93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)
> 附加 : 条件:<kbd>非数字字符</kbd>可以当作<kbd>任意</kbd><kbd>数字字符</kbd>
> 输入样例:
> 11a2b22a037
> 输出结果:
> 114.252.240.37


思考：一开始还以为是十六进制，但与提议不符。如果使用上诉条件，这样造成答案不唯一，<kbd>a=4</kbd><kbd>b=5</kbd>如果按照来推演的话,最多只能到<kbd>f=9</kbd>,但依旧不符合题意。

下方代码不能正确的满足添加条件
```Java
public class Question2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        List<String> list = new ArrayList<String>();
        Map<Character,Character>map=new HashMap<>();
        char[] chars=str.toCharArray();
        for (int i = 0; i < chars.length ; i++) {
            switch (chars[i]){
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    break;
                default:
                    if (!map.containsKey(chars[i])) {
                        map.put(chars[i], (char) (map.getOrDefault(chars[i], '1') + map.size()));
                    }
                    chars[i]=map.get(chars[i]);
                    break;
            }
        }
        str=new String(chars);
        StringBuilder stringBuilder = new StringBuilder(str);
        for (int i = 1; i <= 3; i++) {
            stringBuilder.insert(i, '.');
            for (int j = 1; j <= 3; j++) {
                stringBuilder.insert(i + j + 1, '.');
                for (int k = 1; k <= 3; k++) {
                    stringBuilder.insert(k + i + j + 2, '.');

                    if (isIP(stringBuilder.toString())) {
                        list.add(stringBuilder.toString());
                    }
                    stringBuilder.deleteCharAt(k + i + j + 2);
                }
                stringBuilder.deleteCharAt(i + j + 1);
            }
            stringBuilder.deleteCharAt(i);
        }

        for (String s : list) {
            System.out.println(s);
        }

    }

    public static boolean isIP (String str){
        for (String s : str.split("\\.")) {
            if (s.charAt(0) == '0') {
                return false;
            } else {
                int num = Integer.parseInt(s);
                if (num < 0 || num > 255) {
                    return false;
                }
            }
        }
        return true;
    }
}
```