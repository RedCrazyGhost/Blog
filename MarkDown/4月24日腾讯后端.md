# 4月24日腾讯后端
> 作者 : RedCrazyGhost
> 创建时间 : 2022-04-24
> 修改时间 : 2022-05-20
> 阅读时长 : 13分钟
> 标签 :  <span class="badge bg-primary">Java</span> <span class="badge bg-black">算法</span> 

牛牛站起来！

### Question 1 竖读数字 
> 算法类型 : <span class="badge rounded-pill bg-primary ">模拟</span> 
> 编码模式 : ACM
> 参考题目 : 给定一个有n行的数字字符串，且数字字符串的长度保持一致，通过竖读打印数字字符串<kbd不包含前导0</kbd>，并且按数值大小<kbd>升序</kbd>排列返回结果
> 输入样例 :
> 4
> 0101
> 1001
> 0111
> 1011
> 输出结果 :
> 11 101 1010 1111

```Java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
public class Question1 {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int len=scanner.nextInt();
        String[] strings=new String[len];
        for (int i = 0; i < len; i++) {
            strings[i]= scanner.next();
        }
        int[] arr=new int[strings[0].length()];
        List<String> list1=new LinkedList<>();
        for (int i = 0; i < strings[0].length(); i++) {
            StringBuilder stringBuilder=new StringBuilder();
            for (int j = 0; j < len; j++) {
                stringBuilder.append(strings[j].charAt(i));
            }
            arr[i]=Integer.parseInt(stringBuilder.toString());
        }
        Arrays.sort(arr);
        StringBuilder stringBuilder=new StringBuilder();
        for(int i:arr){
            stringBuilder.append(i).append(' ');
        }
        System.out.println(stringBuilder.deleteCharAt(stringBuilder.length() - 1));
    }
}
```

### Question 2 数组非质数下标循环删除
> 算法类型 : <span class="badge rounded-pill bg-primary ">模拟</span> 
> 编码模式 : 核心代码
> 参考题目 : 传入一个int类型数组，通过每次删除下标（<kbd>数组下标从1开始</kbd>）为非质数的数，删除到数组只剩一个数的时候，返回这个数作为结果
> 输入样例 :
> [1,2,3,4,5,6,7]
> 输出结果 :
> 5

思考：可以通过数学公式推导出数组长度和返回值下标的位置关系，做到时间复杂度为O(1)

```Java
public class Question2 {
    public int getNumber (int[] a) {
        do {
            int len=0;
            for (int i = 1; i <= a.length; i++) {
                if (!IsPrime(i)){
                    a[i-1]=-1;
                }else{
                    len+=1;
                }
            }
            int[] arr=new int[len];
            int index=0;
            for (int i = 0; i < a.length; i++) {
                if (a[i]!=-1){
                    arr[index++]=a[i];
                }
            }
            a=arr;
        }while(a.length!=1);

        return a[0];
    }
    
    //判断质数
    public  boolean IsPrime(int n){
        if (n <= 3) {
            return n > 1;
        }

        for(int i=2;i<=Math.sqrt(n);i++){
            if(n%i == 0)
                return false;
        }
        return true;
    }
}
```
### Question 3 攻防战
> 算法类型 : <span class="badge rounded-pill bg-primary ">字符串</span> 
> 编码模式 : ACM
> 参考题目 : 给一个只包含<kbd>'0'</kbd>和<kbd>'1'</kbd>的字符串，通过划分字符串分为左右两个字符串（两个阵营），左边字符串为一个阵营只记录划分后的<kbd>'0'</kbd>所在下标的总数值为W，反知右边字符串为另一个阵营记录<kbd>'1'</kbd>的总数值为M，然后返回对其求最小的|W-M|。
> 输入样例 :
> 0011
> 输出结果 :
> 1
> 样例解析 :
> 通过中间划分，分成<kbd>"00"</kbd>字符串和<kbd>"11"</kbd>字符串，左边字符串计算的W为1+2=3，右边字符串计算的M为3+4=7，求得|W-M|=4，但这并不是最小值。最小值出现在分成<kbd>"001"</kbd>和<kbd>"1"</kbd>的情况，左边字符串计算的W为1+2=3，右边字符串计算的M为4，求得|W-M|=1。

思考：这个用分治做？

我只过了60%的用例（🤔还是漏了条件）

```Java
import java.util.Scanner;
public class Question3 {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int len=scanner.nextInt();
        int[] arr0=new int[len];
        int[] arr1=new int[len];
        String str=scanner.next();
        for (int i = 0; i <len ; i++) {
            if (str.charAt(i)=='0'){
                if (i==0){
                    arr0[i]=i+1;
                }else {
                    arr0[i] = arr0[i - 1] + i + 1;
                }
            }else{
                if (i==0) {
                    arr0[i] = 0;
                }else{
                    arr0[i] = arr0[i - 1];
                }
            }
        }
        for (int i = len-1; i >-1 ; i--) {
            if (str.charAt(i)=='1'){
                if(i==len-1){
                    arr1[i]=i+1;}else {
                    arr1[i] = arr1[i + 1] + i + 1;
                }
            }else{
                if (i==len-1){
                    arr1[i]=0;
                }else {
                    arr1[i] = arr1[i + 1];
                }
            }
        }
        int min=Integer.MAX_VALUE;
        //下方两次循环有重叠的部分，还可以优化，但最总条件没有判断完全吧
        for (int i = 0; i < len; i++) {
            if (i!=len-1) {
                min = Math.min(min, Math.abs(arr0[i] - arr1[i + 1]));
            }else{
                min=Math.min(min,arr0[i]);
            }
        }
        for (int i = 0; i < len; i++) {
            if (i!=len-1){
                min=Math.min(min,Math.abs(arr1[i]-arr0[i+1]));
            }else{
                min=Math.min(min,arr1[i]);
            }
        }
        System.out.println(min);
    }
}
```
### Question 4 还原循环链表
> 算法类型 : <span class="badge rounded-pill bg-primary ">链表</span> 
> 编码模式 : 核心代码
> 参考题目 : 传入一个部分循环链表片段的ListNode集合，还原循环链表，返回循环链表的顺时针起点或逆时针起点
> 输入样例 :
> [{1,2,3},{2,3,4},{4,1}]
> 输出结果 :
> 1或4
> 结果解析:
> 循环链表实际连接情况:1->2->3->4->...

写错了，冒写出来

### Question 5 股票购买
> 算法类型 : <span class="badge rounded-pill bg-primary ">动态规划</span> 
> 编码模式 : ACM
> 参考题目 : 初始金钱<kbd>m</kbd>,经过<kbd>n</kbd>的股票交易（一天只能<kbd>买</kbd>或<kbd>卖</kbd>一手股票，并且不能"贷款"）后，返回能获取到的最大总资产，总资产由金钱和股票组成，股票最后一天还有剩余的话按最后一天股价计算。
> 输入样例 :
> 6 2
> 2 3 1 1 1 2
> 输出结果 :
> 6
> 样例解析:
> 第一天买入一手股票，第二天卖出一手股票，第三天到第五天连续买入一手股票，第六天卖一出一手股票。总资产就是2元钱+2手股票（最后一天股价为2元）=6

两眼一闭，直接润了
