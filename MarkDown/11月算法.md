# 11月算法
> 作者 : RedCrazyGhost
> 创建时间 : 2021-11-1 
> 修改时间 : 2022-04-28
> 阅读时长 : 51分钟
> 标签 :  <span class="badge bg-secondary">Mac OS</span> <span class="badge bg-primary">Java</span> <span class="badge bg-black">算法</span> 
## 总共30题

### 数组 7题

> #### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate)
> HashSet
>> 时间消耗：5ms 超过55% 内存消耗42.4MB 超过53%
> ```java
> public class Question217 {
>     public boolean containsDuplicate(int[] nums) {
>         Set<Integer> set=new HashSet<>();
>         for( int i:nums){
>             if (!set.add(i)){
>               return true;
>             }
>         }
>         return false;
>     }
> }
> ```
>
>排序
> > 时间消耗：4ms 超过72% 内存消耗41.8MB 超过66%
>```java
>public class Question217 {
>    public boolean containsDuplicate(int[] nums) {
>        Set<Integer> set=new HashSet<>();
>        for( int i:nums){
>            if (!set.add(i)){
>                return true;
>            }
>        }
>        return false;
>    }
>}
>```
>
>HashMap
> > 时间消耗：8ms 超过18% 内存消耗44.5MB 超过21%
>```java
>public class Question217 {
>    public boolean containsDuplicate(int[] nums) {
>        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
>        for (int i = 0; i < nums.length; i++) {
>            if (map.get(nums[i])!=null){
>                return true;
>            }
>            map.put(nums[i],0);
>        }
>        return false;
>    }
>}
>```


> #### [88. 合并两个有序数组]( https://leetcode-cn.com/problems/merge-sorted-array)
>
>把nums2中的元素填充进nums1中，然后进行排序（巧取）
> > 时间消耗：1ms 超过0% 内存消耗38.6MB 超过20%
>```java
>public class Question88 {
>    public void merge(int[] nums1, int m, int[] nums2, int n) {
>        for (int i = 0,j=0; i!=n ; j++) {
>            nums1[j]=(nums1[j]==0?nums2[i++]:nums1[j]);
>        }
>        Arrays.sort(nums1);
>    }
>}
>```


> #### [350. 两个数组的交集 II]( https://leetcode-cn.com/problems/intersection-of-two-arrays-ii)
>HashMap
>> 时间消耗：3ms 超过44% 内存消耗38.6MB 超过49%
>```java
>public class Question350 {
>    public int[] intersect(int[] nums1, int[] nums2) {
>        Map<Integer,Integer> map=new HashMap<>();
>        List<Integer> list=new ArrayList<>();
>        int[] max,min;
>        if (nums1.length> nums2.length){
>            max=nums1;
>            min=nums2;
>        }else{
>            max=nums2;
>            min=nums1;
>        }
>       for (int i = 0; i < min.length; i++) {
>            map.put(min[i],map.getOrDefault(min[i],0)+1);
>        }
>        for (int j = 0; j < max.length; j++) {
>            if (map.getOrDefault(max[j],-99)!=-99&&map.getOrDefault(max[j],-99)>0){
>                list.add(max[j]);
>                map.put(max[j],map.get(max[j])-1 );
>            }
>        }
>        int[] arr=new int[list.size()];
>        for (int i = 0; i < arr.length; i++) {
>            arr[i]=list.get(i);
>        }
>        return arr;
>    }
>}
>```


> #### [566. 重塑矩阵 ]( https://leetcode-cn.com/problems/reshape-the-matrix)
> 解题思路一致，编码可以做迭代优化
>> 时间消耗：1ms 超过33.89% 内存消耗39.6MB 超过7.6%
>```java
>public class Question566 {
>    public int[][] matrixReshape(int[][] mat, int r, int c) {
>        int[][] arr=new int[r][c];
>        int i=0;
>        if(mat.length*mat[0].length==c*r) {
>            while (i < mat.length * mat[0].length) {
>                arr[i / c][i % c] = mat[i / mat[0].length][i % mat[0].length];
>                i++;
>            }
>            return arr;
>        }else {
>            return mat;
>        }
>    }
>}
>```




> #### [36. 有效的数独 ]( https://leetcode-cn.com/problems/valid-sudoku)
>
>HashSet判断是否存在
> > 时间消耗：2ms 超过63.21% 内存消耗38.6MB 超过36.38%
>```java
>public class Question36 {
>    public boolean isValidSudoku(char[][] board) {
>        if (
>                method0(board)&&
>                method1(board)&&
>                        method2(board,0,0)&&
>                        method2(board,0,3)&&
>                        method2(board,0,6)&&
>                        method2(board,3,0)&&
>                        method2(board,3,3)&&
>                        method2(board,3,6)&&
>                        method2(board,6,0)&&
>                        method2(board,6,3)&&
>                        method2(board,6,6)){
>            return true;
>        }else{
>            return false;
>        }
>    }
>    public boolean method0(char[][] board){
>        for (int i = 0; i < 9; i++) {
>            Set<Character> set=new HashSet<>();
>            for (int j = 0; j < 9; j++) {
>                if(board[i][j]!='.') {
>                    if (!set.add(board[i][j])) {
>                        return false;
>                    }
>                }
>            }
>        }
>        return true;
>    }
>    public boolean method1(char[][] board){
>        for (int i = 0; i < 9; i++) {
>            Set<Character> set=new HashSet<>();
>            for (int j = 0; j < 9; j++) {
>                if(board[j][i]!='.') {
>                    if (!set.add(board[j][i])) {
>                        return false;
>                    }
>                }
>            }
>        }
>        return true;
>    }
>    public boolean method2(char[][] board,int x,int y){
>        Set<Character> set=new HashSet<>();
>        for (int i = x; i < x+3; i++) {
>            for (int j = y; j < y+3; j++) {
>                if(board[i][j]!='.') {
>                    if (!set.add(board[i][j])) {
>                        return false;
>                    }
>                }
>            }
>        }
>        return true;
>    }
>}
>```
>循环一遍
>> 时间消耗：1ms 超过100% 内存消耗38.6MB 超过38.76%
>```java
>public class Question36 {
>    public boolean isValidSudoku(char[][] board) {
>        int[][] rows = new int[9][9];
>        int[][] columns = new int[9][9];
>        int[][][] subboxes = new int[3][3][9];
>        for (int i = 0; i < 9; i++) {
>            for (int j = 0; j < 9; j++) {
>                char c = board[i][j];
>                if (c != '.') {
>                    int index = c - '0' - 1;
>                    rows[i][index]++;
>                    columns[j][index]++;
>                    subboxes[i / 3][j / 3][index]++;
>                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
>                        return false;
>                    }
>                }
>            }
>        }
>        return true;
>    }
>}
>```

> #### [73. 矩阵置零 ]( https://leetcode-cn.com/problems/set-matrix-zeroes)
>> 时间消耗：1ms 超过98.1% 内存消耗39.6MB 超过91%
>```java
>public class Question73 {
>    public void setZeroes(int[][] matrix) {
>        List<List<Integer>> list=new ArrayList<>();
>        int index=0;
>        for (int i = 0; i < matrix.length; i++) {
>            for (int j = 0; j < matrix[i].length; j++) {
>                if (matrix[i][j]==0){
>                    List<Integer> list1=new ArrayList<>();
>                    list1.add(i);
>                    list1.add(j);
>                    list.add(list1);}
>            }
>        }
>        for (int i=0;i<list.size();i++){
>            matrix[list.get(i).get(0)]=new int[matrix[list.get(i).get(0)].length];
>            for (int j = 0; j < matrix.length; j++) {
>                matrix[j][list.get(i).get(1)]=0;
>            }
>        }
>    }
>}
>```

> #### [1569. 将子数组重新排序得到同一个二叉查找树的方案数](  https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst)

### 字符串 5题

> #### [387. 字符串中的第一个唯一字符]( https://leetcode-cn.com/problems/first-unique-character-in-a-string)
>HashMap
>> 时间消耗：25ms 超过49.19% 内存消耗38.9MB 超过52.8%
>```java
>public class Question387 {
>    public int firstUniqChar(String s) {
>        char[] chars=s.toCharArray();
>        Map<Character, Integer> map=new HashMap<>();
>        for (int i = 0; i < chars.length; i++) {
>           map.put(chars[i],map.getOrDefault(chars[i],0)+1);
>        }
>            for (int i = 0; i < chars.length; i++) {
>                if(map.get(chars[i])==1){
>                    return i;
>                }
>            }
>            return -1;
>    }
>}
>```


> #### [5. 最长回文子串]( https://leetcode-cn.com/problems/longest-palindromic-substring)

> #### [6. Z 字形变换]( https://leetcode-cn.com/problems/zigzag-conversion)
> HashMap
> > 时间消耗：28ms 超过12% 内存消耗39.1MB 超过22.3%
>```java
>public class Question6 {
>    public String convert(String s, int numRows) {
>        Map<Integer,ArrayList<Character>> map=new HashMap<>();
>        int row=numRows;
>        boolean flag=true;
>        for (int i = 0; i < s.length(); i++) {
>            map.computeIfAbsent(numRows - row, k -> new ArrayList<>());
>            map.get(numRows - row).add(s.charAt(i));
>            if (flag){
>                row--;
>                if (row==1){
>                    flag=false;
>                }
>            }else{
>                row++;
>                if (row==numRows){
>                    flag=true;
>                }
>            }
>        }
>        StringBuilder stringBuilder=new StringBuilder();
>        for(ArrayList<Character> listc:map.values()){
>            stringBuilder.append(listc.stream().map(String::valueOf).collect(Collectors.joining()));
>        }
>        return stringBuilder.toString();
>    }
>}
>```
>官方
> > 时间消耗：3ms 超过93% 内存消耗38.9MB 超过81%
>```java
>public class Question6 {
>    public String convert(String s, int numRows) {
>        if (numRows == 1) return s;
>        StringBuilder sb = new StringBuilder();
>        int n = s.length();
>        int cycleLen = 2 * numRows - 2;
>        for (int i = 0; i < numRows; i++) {
>            for (int j = 0; j + i < n; j += cycleLen) {
>                sb.append(s.charAt(j + i));
>                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)
>                    sb.append(s.charAt(j + cycleLen - i));
>            }
>        }
>        return sb.toString();
>    }
>}
>```

> #### [面试题 17.22. 单词转换]( https://leetcode-cn.com/problems/word-transformer-lcci)

> #### [剑指 Offer II 117. 相似的字符串]( https://leetcode-cn.com/problems/H6lPxb)

### 链表 6题

> #### [141. 环形链表]( https://leetcode-cn.com/problems/linked-list-cycle)
>HashSet
> > 时间消耗：4ms 超过20.83% 内存消耗38.9MB 超过93.68%
>```java
>public class Question141 {
>    public boolean hasCycle(ListNode head) {
>        Set<ListNode> set=new HashSet<>();
>        while(head!=null){
>            if(!set.add(head)){
>                return false;
>            }
>            head=head.next;
>        }
>        return true;
>    }
>}
>```
>快慢指针
> > 时间消耗：0ms 超过100% 内存消耗39.6MB 超过38.98%
>```java
>public class Question141 {
>    public boolean hasCycle(ListNode head) {
>        if (head!=null) {
>            ListNode index0 = head, index1 = head;
>            try {
>                while(index1.next.next!=null){
>                    index0= index0.next;
>                    index1=index1.next.next;
>                    if(index0== index1){
>                        return true;
>                    }
>                }
>            }catch (NullPointerException e){
>                return false;
>            }
>        }
>        return false;
>    }
>}
>```


> #### [206. 反转链表]( https://leetcode-cn.com/problems/reverse-linked-list)
>ArrayList
>> 时间消耗：1ms 超过5.52% 内存消耗38.1MB 超过67.2%
>```java
>public class Question206 {
>    public ListNode reverseList(ListNode head) {
>        ListNode a=head,b=head;
>        List<Integer> list=new ArrayList<>();
>        while(head!=null){
>            list.add(head.val);
>            head=head.next;
>        }
>        for (int i = list.size()-1; i >-1; i--) {
>            a.val=list.get(i);
>            a=a.next;
>        }
>        return b;
>    }
>}
>```
>链表逆序
>> 时间消耗：0ms 超过100% 内存消耗38.2MB 超过59.83%
>```java
>public class Question206 {
>    public ListNode reverseList(ListNode head) {
>       ListNode index=null,index1=null,listNode = new ListNode();
>        while(head!=null){
>            index=head;
>            head=head.next;
>            listNode.next=index;
>            index.next=index1;
>            index1=index;
>        }
>        return listNode.next;
>    }
>}
>```

> #### [19. 删除链表的倒数第 N 个结点]( https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)
> 获取链表长度(深度)，正序定位节点删除
> > 时间消耗：0ms 超过100% 内存消耗36.5MB 超过26.92%
>```java
>public class Question19 {
>    public ListNode removeNthFromEnd(ListNode head, int n) {
>        ListNode listNode=new ListNode(),index=listNode,index0=head;
>        while (head!=null){
>            head=head.next;
>            n--;
>        }
>        head=index0;
>        while (head!=null){
>            n++;
>            ListNode o=head;
>            head=head.next;
>            o.next=null;
>            if (n!=1) {
>                listNode.next = o;
>                listNode = listNode.next;
>            }
>        }
>        return index.next;
>    }
>}
>```

> #### [86. 分隔链表]( https://leetcode-cn.com/problems/partition-list)
> 双链表拼接
> > 时间消耗：0ms 超过100% 内存消耗37.9MB 超过8.3%
>```java
>public class Question86 {
>    public ListNode partition(ListNode head, int x) {
>        ListNode listmin=new ListNode(),minindex=listmin;
>        ListNode listmax=new ListNode(),maxindex=listmax;
>        while(head!=null) {
>            ListNode o = head;
>            head = head.next;
>            o.next = null;
>            if (o.val < x) {
>                listmin.next = o;
>                listmin = listmin.next;
>            } else {
>                listmax.next = o;
>                listmax = listmax.next;
>            }
>        }
>        if (minindex.next !=null) {
>            minindex = minindex.next;
>            maxindex = maxindex.next;
>            listmin.next = maxindex;
>            return minindex;
>        }else {
>            return maxindex.next;
>        }
>    }
>}
>```

> #### [面试题 04.03. 特定深度节点链表]( https://leetcode-cn.com/problems/list-of-depth-lcci)

> #### [面试题 16.25. LRU 缓存]( https://leetcode-cn.com/problems/lru-cache-lcci)

### 栈/队列 5题

> #### [232. 用栈实现队列]( https://leetcode-cn.com/problems/implement-queue-using-stacks)

> #### [20. 有效的括号]( https://leetcode-cn.com/problems/valid-parentheses)
> Stack
>> 时间消耗：1ms 超过98.91% 内存消耗36.4MB 超过66.85%
>```java
>public class Question20 {
>    public boolean isValid(String s) {
>        Stack<Character> stack=new Stack<>();
>        try {
>            for (int i = 0; i < s.length(); i++) {
>                switch (s.charAt(i)) {
>                    case '[':
>                    case '{':
>                    case '(':
>                        stack.push(s.charAt(i));
>                        break;
>                    case '}':
>                        if (stack.pop() != '{') {
>                            return false;
>                        }
>                        break;
>                    case ')':
>                        if (stack.pop() != '(') {
>                            return false;
>                        }
>                        break;
>                    case ']':
>                        if (stack.pop() != '[') {
>                            return false;
>                        }
>                        break;
>                }
>            }
>            if (stack.isEmpty()){
>                return true;
>            }else{
>                return false;
>            }
>        }catch (Exception e){
>            return false;
>        }
>    }
>}
>```

> #### [1614. 括号的最大嵌套深度]( https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses)
> Stack最大size
> > 时间消耗：1ms 超过0% 内存消耗36.6MB 超过32%
>```java
>public class Question1614 {
>    public int maxDepth(String s) {
>        Stack<Character> stack=new Stack<>();
>        int depth=0;
>        for (int i = 0; i < s.length(); i++) {
>            if (s.charAt(i)=='('){
>                stack.push(s.charAt(i));
>            }
>            if (s.charAt(i)==')'){
>                stack.pop();
>            }
>            depth=Math.max(stack.size(),depth);
>        }
>        return depth;
>    }
>}
>```
> 迭代优化
> > 时间消耗：0ms 超过100% 内存消耗36.3MB 超过89%
>```java
>public class Question1614 {
>    public int maxDepth(String s) {
>        int depth=0;
>        int num=0;
>        for(char c:s.toCharArray()){
>            if (c=='('){
>                num+=1;
>                depth=Math.max(num,depth);
>            }
>            if (c==')'){
>                num-=1;
>            }
>        }
>        return depth;
>    }
>}
>```

> #### [剑指 Offer 30. 包含min函数的栈]( https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof)

> #### [剑指 Offer II 037. 小行星碰撞]( https://leetcode-cn.com/problems/XagZNi)

### 树 7题

> #### [144. 二叉树的前序遍历]( https://leetcode-cn.com/problems/binary-tree-preorder-traversal)
> 递归
> > 时间消耗：0ms 超过100% 内存消耗36.3MB 超过99%
>```java
>public class Question144 {
>    List<Integer> list;
>    public List<Integer> preorderTraversal(TreeNode root) {
>        list=new ArrayList<>();
>        if (root!=null) {
>            function(root);
>        }
>        return list;
>    }
>    public void function(TreeNode node){
>        list.add(node.val);
>        if(node.left!=null){
>            function(node.left);
>        }
>        if (node.right!=null){
>            function(node.right);
>        }
>    }
>}
>```

> #### [102. 二叉树的层序遍历]( https://leetcode-cn.com/problems/binary-tree-level-order-traversal)
> 递归+HashMap
> > 时间消耗：1ms 超过0% 内存消耗38.3MB 超过92%
>```java
>public class Question102 {
>    List<List<Integer>> list;
>    Map<Integer,List<Integer>> map;
>    public List<List<Integer>> levelOrder(TreeNode root) {
>        list=new ArrayList<>();
>        map=new HashMap<>();
>        if (root==null){
>            return list;
>        }
>        function(root,0);
>        for (int i = 0; i < map.size(); i++) {
>            list.add(map.get(i));
>        }
>        return list;
>    }
>    public void function(TreeNode node,int i){
>        map.put(i, map.getOrDefault(i, new ArrayList<>()));
>        map.get(i).add(node.val);
>        i+=1;
>        if (node.left!=null){
>            function(node.left,i);
>        }
>        if (node.right!=null){
>            function(node.right,i);
>        }
>    }
>}
>```

> #### [226. 翻转二叉树]( https://leetcode-cn.com/problems/invert-binary-tree)
>递归
> > 时间消耗：0ms 超过100% 内存消耗35.9MB 超过41%
>```java
>public class Question226 {
>    public TreeNode invertTree(TreeNode root) {
>        if (root!=null) {
>            function(root);
>        }
>        return root;
>    }
>    public void function(TreeNode node){
>        if (node.right!=null&&node.left!=null){
>            TreeNode temp= node.left;
>            node.left=node.right;
>            function(node.left);
>            node.right=temp;
>            function(node.right);
>        } else if (node.right!=null&&node.left==null){
>            node.left=node.right;
>            node.right=null;
>            function(node.left);
>        }else if (node.right==null&&node.left!=null){
>            node.right=node.left;
>            node.left=null;
>            function(node.right);
>        }
>    }
>}
>```


> #### [701. 二叉搜索树中的插入操作]( https://leetcode-cn.com/problems/insert-into-a-binary-search-tree)
>递归
> > 时间消耗：0ms 超过100% 内存消耗39MB 超过68%
>```java
>public class Question701 {
>    public TreeNode insertIntoBST(TreeNode root, int val) {
>        if (root==null){
>            return new TreeNode(val);
>        }
>        function(root, val);
>        return root;
>    }
>    public void function(TreeNode node,int val){
>        if (node.val<val){
>            if (node.right==null){
>                node.right=new TreeNode(val);
>            }else{
>                function(node.right,val);
>            }
>        }else{
>            if (node.left==null){
>                node.left=new TreeNode(val);
>            }else{
>                function(node.left,val);
>            }
>        }
>    }
>}
>```


> #### [98. 验证二叉搜索树]( https://leetcode-cn.com/problems/validate-binary-search-tree)
> 官方
> > 时间消耗：0ms 超过100% 内存消耗38MB 超过70%
>```java
>public class Question98 {
>    public boolean isValidBST(TreeNode root) {
>       return function(root,Long.MIN_VALUE,Long.MAX_VALUE);
>    }
>    public boolean function(TreeNode node,long min,long max){
>       if(node==null){
>           return true;
>       }
>       if (node.val<=min||node.val>=max){
>           return false;
>       }
>        return function(node.left,min,node.val)&&function(node.right,node.val,max);
>    }
>}
>```

> #### [653. 两数之和 IV - 输入 BST]( https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst)

> #### [LCP 34. 二叉树染色]( https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC)

